# vdom起步

> 说明：完全参照`snabbdom`实现，包括配置、构建过程及使用的开发语言。是1:1复刻版本。这个项目的意义不在于相同代码的编写，而是代码的分析。同样还有对工程化实践的一些分析。

## 项目结构

|-snabbdom-study
|--.github目录
|----workflows目录
|-----steps.yml
|--expamples目录
|--test目录
|--perf目录
|--.husky目录
|--src目录
|--package.json
|--.eslintrc.js
|--karma.conf.js
|--serve.json
|--tsconfig.json

## 初始化项目
1. 进入到`VDom`目录下，运行`npm init`,生成`package.json`文件。
2. 按照`snabbdom`的`package.json`中依赖包安装依赖。

## 几个依赖包的说明

### `release-it`

这个包是自动化版本控制及包发布相关的工具。可以配置为执行`git`相关命令时触发，比如`commit、tag、push`等。发布`npm`包的时候也可以使用此工具进行管理。

> Generic CLI tool to automate versioning and package publishing related tasks.

### `@release-it/conventional-changelog`

这个包和`release-it`配合使用，记录更新日志。

### `cross-env`

这个包的作用是抹平命令行脚本在平台之间的差异性。这个包处在维护阶段，不会继续更新。最新的包是`cross-env-shell`。

## `TypesSript`相关

### 依赖安装

将`TypesSript`安装为本地依赖即可。所使用的版本是`4.6.3`。 除此之外，还需要安装若干相关库。
- `@types/chai`，和`TypesSript`相关的断言库。
- `@types/lodash.shuffle`,为`TypesSript`提供功能的`lodash.shuffle`库。
- `@types/mocha`,为`TypesSript`提供功能的`mocha`库。
- `karma-typescript`,测试库
- `@typescript-eslint/eslint-plugin`
- `@typescript-eslint/parser`,解析`ESTree`的工具。

### 配置

`TypesSript`不能直接运行在浏览器环境，需要编译转换成`JavaScript`。在这个过程中需要使用配置文件来提供转换选项。

`TypesSript`有两种方式配置文件，`tsconfig.json` 和`jsconfig.json`，选择其中任何一种都可以。本项目使用 `tsconfig.json`。具体编译选项如下：

```tsconfig.json
	{
		"compilerOptions": {
			"removeComments": false,
			"sourceMap": true,
			
			"declaration": true,
			"strict": true,
			"strictFunctionTypes": false,
			"moduleResolution": "node",
			"target": "es6",
			
			"outDir": "build"
		},
		"include": ["./src/index.ts"]
	}

```
编译选项说明:

- `declaration`,为你工程中的每个 `TypeScript` 或 `JavaScript` 文件生成 `.d.ts` 文件。 这些 `.d.ts `文件是描述模块外部 `API` 的类型定义文件。 像 `TypeScript` 这样的哦你根据可以通过 `.d.ts `文件为非类型化的代码提供 `intellisense` 和精确的类型。

- `moduleResolution`,指定模块解析策略：'node' 。
- `strictFunctionTypes`,开启后表示对参数进行更严格的检查策略。
- `include`,相对配置文件的路径，找到数组中的项进行编译

### 编译

`TypesSript`使用`tsc`编译。在本工程中，配置在`package.json`的脚本段，使用`npm run build` 进行编译。

```
	"scripts":{
		"build" : "tsc && npm run bundle:cjs",
		"bundle:cjs": "rollup build/index.js --format cjs --file build/vdom.cjs.js"
	}
```


## 代码及版本管理相关

### 依赖安装

需要安装`release-it`、`commithelper`、`@release-it/conventional-changelog`、`husky`、`conventional-changelog-angular`、`lint-staged`。

### 配置及执行

1. `release-it`的配置，需要在`package.json`文件中添加配置段，也可以在项目根目录下新建配置文件，在`package.json`配置如：

```
	"release-it": {
		"git": {
			"commitMessage": "chore(release): v${version}"
		},
		"github": {
			"release": true
		},
		"plugins": {
			"@release-it/conventional-changelog": {
				"preset": "angular",
				"infile": "CHANGELOG.md"
			}
		}
	},
```

> `release-it`在 `release`的时候起作用，`release`配置在脚本段中，使用`npm run release`执行发布。
```
	"scripts":{
		"release":"npm run test && release-it"
	}
```

2. `commithelper`的作用是是提交代码时的信息规范化，有提示和检查两种功能。通过回答问题的方式填写提交信息，并在在提交阶段检查提交信息是否规范。 `commithelper`的配置，需要在`package.json`文件中添加配置段：

```
	"commithelper": {
		"scopeOverrides": {
			"chore": [
				"tools",
				"refactor",
				"release",
				"test",
				"deps",
				"docs",
				"examples"
			]
		}
  	}
```

> `commithelper` 的执行需要在`package.json`的脚本段中添加`npm`命令：
```
	"scripts":{
		"prepare":"husky install"
	}
```
`husky`是一个产生`git hooks`的库，当提交代码的时候执行一些指令。要让`commithelper` 和 `husky`建立关系，需要在
 
当执行`npm run prepare`的时候，终端会提示：`husky - Git hooks installed`,这样会在项目的根目录下产生一个`.husky`的目录，手动在下边添加三个文件。分别是`commit-msg`、`pre-commit`和`prepare-commit-msg`。有了这些文件，就可以在文件中和`commithelper`产生关联了。
`commit-msg`中的脚本是：
```
	#!/bin/sh
	. "$(dirname "$0")/_/husky.sh"

	./node_modules/.bin/commithelper check --file $1 --fix
```
就是在执行`git commit`的时候检查提交信息是否符合规范。

`pre-commit`中的脚本是：
```
	#!/bin/sh
	. "$(dirname "$0")/_/husky.sh"

	./node_modules/.bin/lint-staged

```
就是在`git commit`之前，使用`lint-staged`检查代码的规范性。

`prepare-commit-msg`中的脚本是：
```
	#!/bin/sh
	. "$(dirname "$0")/_/husky.sh"

	exec < /dev/tty && ./node_modules/.bin/commithelper prompt --file $1
```
同样，通过问答的方式填写提交信息，并检查。

> 注意：
> 1. 官网介绍是手动创建`.husky`目录，并在下边创建三个文件，将可执行脚本复制到对应文件中。然后才执行 `npm run prepare`产生`git hook`文件，这个文件的名称是`husky.sh`在`.husky`目录的子目录`_`下。
> 2. 同样需要注意的是，手动创建的三个文件在`.husky`目录下。
> 3. 如果提示`hint: The '.husky/pre-commit' hook was ignored because it's not set as executable.` 需要执行`chmod 744 pre-commit`给改文件加上执行权限。
> 4. 到这一步，执行`git commit`会报错，因为在`pre-commit`文件中，需要执行代码检查`lint-staged`,所以需要先把代码检查先配置好。
> 使用项目中`node_modules`的`commithelper`替换 `exec < /dev/tty && npm exec commithelper -- prompt --file $1`中的`npm exec`。在新版本的`npm`中没有了`exec`踪影。

除了以上步骤，还需要在添加`commithelper`的配置段：

```
"commithelper": {
    "scopeOverrides": {
      "chore": [
        "tools",
        "refactor",
        "release",
        "test",
        "deps",
        "docs",
        "examples"
      ]
    }
  }
```
> 注意：配置完成后，提交时只需运行`git commit`即可，剩下都是通过鼠标选择提交信息。不需要带`-m`参数。

3. `lint-staged`的作用是对受控的`git`代码进行检查，不让大便一样的代码进入代码库。使用这个库的好处是拒绝错误、统一代码风格。可以配置对那些文件进行检查，通常配合 `husky` 在`pre-commit`阶段使用。即可以单独创建文件进行配置，也可以在`package.json`中添加配置段。在`package.json`中配置如下:
```package.json
  "lint-staged": {
    "*.(ts|tsx|js|md)": "prettier --write"
  },
```
这里不对`markdown`文件进行检查，把`md`去掉即可。

## 代码规范

代码的规范主要靠`eslint`插件保证，还有一些辅助插件，保证功能的完备性及正确性。比如`eslint-config-prettier`,这个插件的组要用途是防止`eslint`的配置和`prettier`插件的配置冲突；`eslint-plugin-import`,这个插件提供对`ES2015+ (ES6+) import/export`语法的规范；`eslint-plugin-markdown`提供对`markdown`中展示代码规范；`eslint-plugin-node`提供对`node.js`代码的规范；同样，`@typescript-eslint/eslint-plugin`是对`TypeScript`代码提供规范。

除了对代码书写规范以外，还需要对格式进行了统一，这个环节由`prettier`插件进行保障。

### `eslint`配置及执行

`eslint`配置在单独的文件中，在项目根目录下创建一个`.eslintrc.js`文件，将配置项写入。这个文件一般使用现有模板，然后根据需要进行修改。

执行`eslint`检查的时机有两个，一个是在`package.json`的`scripts`配置命令，编写完阶段性的代码后执行`npm run `命令进行检查，这种方式的主要缺陷是完全靠程序员的自觉性；二是在代码提交时进行检查，这个`eslint-stage`进行保证。
`javascripts`段中命令的配置：
```
	"scripts":{
		"lint": "eslint --ext .ts,.tsx,.js --ignore-path .gitignore .",
	}
```

### `prettier`配置及执行

`prettier`配置在`package.json`中增加一个配置段。
```
	"prettier": {},
```
执行在`scripts`中增加一个命令：

```
	"scripts":{
		"format": "prettier --write .",
	}
```

同时在根目录下创建了一个`.prettierignore`文件，配置忽略格式化的文件。
```
	build/
	node_modules/
	coverage/
```
## 测试

### 依赖安装

测试使用了一套组合工具。测试框架是`karma`,断言库使用`chai`。在`karma`运行时，又使用了`mocha`。为了支持测试各种浏览器的表现，又引入了特定浏览器的插件。为了支持`TypeScript`测试，引入了`karma-typescript`。所以，测试涉及到的全部插件如下:

- `chai`
- `mocha`
- `karma`
- `karma-browserstack-launcher`,这个插件和`browserstack`平台绑定，付费使用。
- `karma-chrome-launcher`
- `karma-firefox-launcher`
- `karma-mocha`
- `karma-mocha-reporter`
- `karma-typescript`

### 执行测试

在`package.json`脚本段中定义了三种测试命令，分别用于单元测试，编译时测试和持续集成时的测试。

```
	"scripts":{
	
		"unit": "cross-env FILES_PATTERN=\"test/unit/*.ts,test/unit/*.tsx\" karma start karma.conf.js",
		"test:ci": "npm test && cross-env ES5=true npm run unit",
    	"test": "npm run build && npm run lint && npm run unit"
	}
```

除了在`package.json`脚本段中配置命令外，还需要创建一个`karma.conf.js`。 在此仅仅是描述流程，不去测试多浏览器兼容情况，所以不用`browserstack`平台,只使用`Chrome`。

具体参考:

> [karma配置](https://karma-runner.github.io/6.4/config/configuration-file.html)，[karma-chrome-launcher配置](https://www.npmjs.com/package/karma-chrome-launcher)，[karma-typescript配置](https://www.npmjs.com/package/karma-typescript)，[karma-firefox-launcher配置](https://www.npmjs.com/package/karma-firefox-launcher)。

## 项目其他配置

在项目的根目录下，还有一些其他的配置目录或文件，列举如下：

- `.vscode`目录下有个`settings.json`文件，配置代码：
```
{
  "typescript.tsdk": "node_modules/typescript/lib",
  "eslint.validate": [
    "javascript",
    "javascriptreact",
    "markdown",
    "typescript",
    "typescriptreact"
  ],
  "eslint.options.ignorePath": ".gitignore"
}
```
这个配置在当前项目中生效。

- `.prettierignore`文件，这个配置了忽略格式化的目录或文件。配置：
```
	build/
	node_modules/
	coverage/
```

- `.npmignore`,配置了在发布包的时候忽略的文件。默认情况下，下列会被忽略，无须明确写在配置文件中:

```
	.*.swp
	._*
	.DS_Store
	.git
	.hg
	.npmrc
	.lock-wscript
	.svn
	.wafpickle-*
	config.gypi
	CVS
	npm-debug.log
```
还可以增加额外的忽略内容，可以是目录:
```
	/coverage/
```

- `.nvmrc`和`.node-version`

记录使用的`node`版本号。
```
v16.14.2
```
